title: Основы реляционной алгебры
---
body:

# 1.1 Как устроена реляционная модель?

База данных это множество именованных отношений - таблиц <small><i>(отношение или relatio фундаментальное понятие в реляционной модели именно поэтому модель называется реляционной - Прим. wiki)</i></small>.

Само по себе отношение является множеством, которое содержит список кортежей  представляющих строки таблицы. Например, если представить таблицу с тремя столбцами (Name, City, Job), то саму таблицу можно показать в виде множества кортежей - строк:

```python
{
    (Kris, Berlin, Database Designer),
    (Mike, Zurich, SRE),
    (Harald, Berlin, Security Engineer)
}
```

Строки отношения всегда не упорядочены, так как являются частью множества. Значения же кортежей всегда упорядочены, так как значения являются частью кортежей, а не множества. Тут важно заметить, что выражение ORDER BY в языке SQL не является частью его реляционной алгебры.

Каждые элемент кортежа это именованный атрибут или столбец <small><i>(или именованный кортеж, где название атрибута это столбец, а его значение - значение столбца соответственно - Прим. авт.)</i></small>. Атрибуты имеют тип, который иногда называется доменом. (описать какие типы могут существовать).

Также есть специальное значение, которым может быть установлен столбец любого типа. Это специальное значение именуется NULL, оно играет очень важную роль в реляционных базах данных. NULL используются для обозначения того, что значение может быть неизвестным или неопределенным.

Еще одним важным атрибутом отношения является ключ. Каждое значение такого атрибута должно быть уникальным. У подобных атрибутов есть несколько важных применений. Одно из них - извлечение определенных кортежей. Например, вы можете запросить кортеж по его уникальном ключу. В то же время система баз данных для эффективности строит специальную структуру индексов для более быстрого нахождения кортежей.

Более важное применение ключей это создание связей между кортежами отношений по их уникальному ключу, так как в реляционных базах данных нет концепции указателей.

# 1.2 Важная терминология

* Схема - структурированное описание отношения в базе данных. Схема содержит в себе название отношения, атрибуты этого отношения и типы этих атрибутов.

* Экземпляр - фактическое содержание в данный момент времени. Схема устанавливается заранее, а затем экземпляры данных будут меняться со временем.

# 1.3 Выполнение запросов в реляционных базах данных

Основные шаги в создании и использовании реляционных баз данных.

* Проектирования схемы; создание используя язык DDL (Data Definition Language). Схема содержит структуру отношений и атрибуты этих отношений.

* Начальная загрузка исходных данных

Реляционная алгебра это формальный язык, который формирует основы таких языков, как SQL.

Запросы в реляционных базах данных действуют на отношения, которые так же в свою очередь порождают новые отношения.

Самый простой запрос в реляционной алгебре это запрос самого отношения: $$Relation$$ что вернет копию самого отношения.

# 1.4 Оператор выборки (ограничение)

Оператор выборки служит для фильтрации определенных строк отношений. Оператор обозначается греческой буквой сигма <p>$$\sigma$$</p> с контекстом обозначающим условие, которое используется для фильтрации строк извлеченных из отношения:

<p>$$\sigma_{condition}Relation$$</p>

Например, следующим запросом можно выбрать студентов университета "Stanford" с оценкой больше 3.7 учащихся на факультете "Computer Science":

<p>$$\sigma_{cName="Stanford" \wedge gpa > 3.7 \wedge major = "Computer Science"} Student$$</p>

# 1.5 Оператор проекции

Оператор проекции служит для выборки определенных столбцов отношения. Оператор обозначается греческой буквой пи <p>$$\pi$$</p> и в качестве контекста указывается список колонок:

<p>$$\pi_{a_{1}...a_{n}}Relation$$</p>

Пример того, как можно комбинировать оператор выборки и проекции. Выберем id студентов с gpa > 3.7:

<p>$$\pi_{id}(\sigma_{gpa>3.7}Student)$$</p>

# 1.6 Дубликаты

Семантика реляционной алгебры устраняет дубликаты, так как она основана на множествах. Это немного отличает реляционную алгебру от языка SQL. Устранение дубликатов является ресурсоемкой задачей, поэтому нецелесообразно использовать обычные множества в языке SQL. Вместо этого используются мультимножества, где данные могут дублироваться, а устранение дубликатов можно добиться добавлением оператора DISTINCT.

# 1.7 Декартово произведение

Декартово произведение служит для комбинации двух отношений. Данный оператор берет два отношения создавая пары всех возможных комбинаций кортежей. Например, результатом выражения:

<p>$$Employee\times Parking$$</p>

для двух отношений:

```
+----------+-------+
| Employee         |
+----------+-------+
| iD       | Name  |
+----------+-------+
| 1001     | Bob   |
| 1002     | Alice |
| 1003     | Rob   |
+----------+-------+
```

```
+---------+-------+
| Parking         |
+---------+-------+
| iD      | Space |
+---------+-------+
| 1001    | 6     |
| 1002    | 8     |
| 1004    | 1     |
+---------+-------+
```

Будет множество с количеством кортежей в отношении Employee умноженное на количество кортежей в отношении Parking:

```
+-------------+---------------+------------+---------------+
| Employee.Id | Employee.Name | Parking.Id | Parking.Space |
+-------------+---------------+------------+---------------+
|        1001 | Bob           |       1001 |             6 |
|        1001 | Bob           |       1002 |             8 |
|        1001 | Bob           |       1004 |             1 |
|        1002 | Alice         |       1001 |             6 |
|        1002 | Alice         |       1002 |             8 |
|        1002 | Alice         |       1004 |             1 |
|        1003 | Rob           |       1001 |             6 |
|        1003 | Rob           |       1002 |             8 |
|        1003 | Rob           |       1004 |             1 |
+-------------+---------------+------------+---------------+
```

Декартово произведение в нашем случае является бинарным оператором, поэтому для соединения более двух отношении необходимо использовать скобки.

<p>$$Person \times (Employee \times Parking)$$</p>

Само по себе декартово произведение не так полезно, если его не использовать с другими операторами.

Например, мы хотим получить место парковки Боба. Для этого используя декартово произведение можно применить оператор выборки на сравнение Employee.Id и Parking.Id к результату полученного отношения:

<p>$$\pi_{Employee.Name, Parking.Space} (\sigma_{Employee.Id = Parking.Id \wedge Employee.Name = 'Bob'} (Employee \times Parking))$$</p>

В результате получим отношение

```
+---------------+---------------+
| Employee.Name | Parking.Space |
+---------------+---------------+
| Bob           |             6 |
+---------------+---------------+
```

# 1.8 Естественное соединение

Естественное соединение использует декартово произведение, но позволяет обеспечить сравнение значений всех атрибутов с одинаковым названием по умолчанию, а также устранить дубликаты атрибутов:

<p>$$Employee \bowtie Parking$$</p>

```
+------+-------+-------+
|  Id  | Name  | Space |
+------+-------+-------+
| 1001 | Bob   |     6 |
| 1002 | Alice |     8 |
+------+-------+-------+
```

Пример решения задачи отображения места парковки Боба используя оператор естественного соединения:

<p>$$\pi_{Name, Space}(\sigma_{Name = 'Bob'}(Employee \bowtie Parking))$$</p>

```

+------+-------+
| Name | Space |
+------+-------+
| Bob  |     6 |
+------+-------+
```

# 1.9 Тета соединение

Тета соединение, так же как и естественное соединение является всего лишь сокращенной записью оператора выборки и декартова произведения. Тета - это контекст, в который передается условное выражения вместо оператора выборки:

<p>$$Exp_{1} \bowtie_{\theta}(Exp_{1} \times Exp_{2})$$</p>

В большинстве реляционных базах данных в качестве оператора JOIN используется именно тета соединение.

Для наглядности мы можем переписать наш предыдущий запрос получения места парковки Боба используя тета соединение:

<p>$$\pi_{Name, Space}(Employee \bowtie_{Name='Bob'} Parking)$$</p>

# 2.0 Множества

## 2.0.1 Оператор объединения

Все операторы, которые были описаны выше используются для объединения кортежей таблиц по горизонтали. А что если необходимо объединить в один список значения из разных таблиц? Для этого удобнее всего будет воспользоваться оператором объединения, который ожидает, что типы объединяемых столбцов и их количество одинаковы.

Например, можно объединить столбцы Id отношений Parking и Employee:

<p>$$\pi_{Id}Employee \cup \pi_{Id}Parking$$</p>

```
+------+
|  Id  |
+------+
| 1001 |
| 1002 |
| 1003 |
| 1004 |
+------+
```

Так как мы оперируем множествами, то можно представить оператор объединения в виде диаграммы Венна, где между двумя множествами Parking и Employee выполняется логический оператор ИЛИ:

![](Venn0111.svg)

## 2.0.2 Оператор разности

Оператор разности для отношений работает так же как и для множеств, так как отношения являются сами по себе множествами, как мы рассмотрели ранее.

Например, нам нужно получить список свободных парковочных мест. Для этого мы можем применить оператор разности между отношениями Employee и Parking:

<p>$$\pi_{Id} Parking - \pi_{Id} Employee$$</p>

```
+------+
|  Id  |
+------+
| 1004 |
+------+
```

Диаграмма Венна для оператора разности двух множеств

![](Venn0100.svg)

Но данный запрос в качестве результата покажет только Id парковочных мест. Что если мы хотели бы показать еще и номера свободных парковочных мест? Мы не можем добавить в контекст проекции атрибут Space, так как это исказит наше множество. Для этого мы можем применить естественное соединение к полученному результату из множества Id свободных парковочных мест:

<p>$$\pi_{Id, Space}((\pi_{Id}Parking - \pi_{Id}Employee) \bowtie Parking)$$</p>

```
+------+-------+
|  Id  | Space |
+------+-------+
| 1004 |     1 |
+------+-------+
```
---
pub_date: 2018-12-13
---
toc: Содержание
