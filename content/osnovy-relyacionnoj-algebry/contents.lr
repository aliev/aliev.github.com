title: Основы реляционной алгебры
---
body:

# 1.1 Как устроена реляционная модель?

База данных это множество именованных отношений - таблиц <small><i>(отношение или relatio фундаментальное понятие в реляционной модели именно поэтому модель называется реляционной - Прим. wiki)</i></small>.

Само по себе отношение является множеством, которое содержит список кортежей  представляющих строки таблицы. Например, если представить таблицу с тремя столбцами (Name, City, Job), то саму таблицу можно показать в виде множества кортежей - строк:

```python
{
    (Kris, Berlin, Database Designer),
    (Mike, Zurich, SRE),
    (Harald, Berlin, Security Engineer)
}
```

Строки отношения всегда не упорядочены, так как являются частью множества. Значения же кортежей всегда упорядочены, так как значения являются частью кортежей, а не множества. Тут важно заметить, что выражение ORDER BY в языке SQL не является частью его реляционной алгебры.

Каждые элемент кортежа это именованный атрибут или столбец <small><i>(или именованный кортеж, где название атрибута это столбец, а его значение - значение столбца соответственно - Прим. авт.)</i></small>. Атрибуты имеют тип, который иногда называется доменом. (описать какие типы могут существовать).

Также есть специальное значение, которым может быть установлен столбец любого типа. Это специальное значение именуется NULL, оно играет очень важную роль в реляционных базах данных. NULL используются для обозначения того, что значение может быть неизвестным или неопределенным.

Еще одним важным атрибутом отношения является ключ. Каждое значение такого атрибута должно быть уникальным. У подобных атрибутов есть несколько важных применений. Одно из них - извлечение определенных кортежей. Например, вы можете запросить кортеж по его уникальном ключу. В то же время система баз данных для эффективности строит специальную структуру индексов для более быстрого нахождения кортежей.

Более важное применение ключей это создание связей между кортежами отношений по их уникальному ключу, так как в реляционных базах данных нет концепции указателей.

# 1.2 Важная терминология

* Схема - структурированное описание отношения в базе данных. Схема содержит в себе название отношения, атрибуты этого отношения и типы этих атрибутов.

* Экземпляр - фактическое содержание в данный момент времени. Схема устанавливается заранее, а затем экземпляры данных будут меняться со временем.

# 1.3 Выполнение запросов в реляционных базах данных

Основные шаги в создании и использовании реляционных баз данных.

* Проектирования схемы; создание используя язык DDL (Data Definition Language). Схема содержит структуру отношений и атрибуты этих отношений.

* Начальная загрузка исходных данных

Реляционная алгебра это формальный язык, который формирует основы таких языков, как SQL.

Запросы в реляционных базах данных действуют на отношения, которые так же в свою очередь порождают новые отношения.

Самый простой запрос в реляционной алгебре это запрос самого отношения: $$Relation$$ что вернет копию самого отношения.

# 1.4 Оператор выборки (ограничение)

Оператор выборки служит для фильтрации определенных строк отношений. Оператор обозначается греческой буквой сигма <p>$$\sigma$$</p> с контекстом обозначающим условие, которое используется для фильтрации строк извлеченных из отношения:

<p>$$\sigma_{condition}Relation$$</p>

Например, следующим запросом можно выбрать студентов университета "Stanford" с оценкой больше 3.7 учащихся на факультете "Computer Science":

<p>$$\sigma_{cName="Stanford" \wedge gpa > 3.7 \wedge major = "Computer Science"} Student$$</p>

# 1.5 Оператор проекции

Оператор проекции служит для выборки определенных столбцов отношения. Оператор обозначается греческой буквой пи <p>$$\pi$$</p> и в качестве контекста указывается список колонок:

<p>$$\pi_{a_{1}...a_{n}}Relation$$</p>

Пример того, как можно комбинировать оператор выборки и проекции. Выберем id студентов с gpa > 3.7:

<p>$$\pi_{id}(\sigma_{gpa>3.7}Student)$$</p>

# 1.6 Дубликаты

Семантика реляционной алгебры устраняет дубликаты, так как она основана на множествах. Это немного отличает реляционную алгебру от языка SQL. Устранение дубликатов является ресурсоемкой задачей, поэтому нецелесообразно использовать обычные множества в языке SQL. Вместо этого используются мультимножества, где данные могут дублироваться, а устранение дубликатов можно добиться добавлением оператора DISTINCT.

# 1.7 Декартово произведение

Декартово произведение служит для комбинации двух отношений. Данный оператор берет два отношения создавая пары всех возможных комбинаций кортежей. Например, результатом выражения:

<p>$$Employee\times Parking$$</p>

для двух отношений:

```
+----------+-------+
| Employee         |
+----------+-------+
| iD       | Name  |
+----------+-------+
| 1001     | Bob   |
| 1002     | Alice |
| 1003     | Rob   |
+----------+-------+
```

```
+---------+-------+
| Parking         |
+---------+-------+
| iD      | Space |
+---------+-------+
| 1001    | 6     |
| 1002    | 8     |
| 1004    | 1     |
+---------+-------+
```

Будет множество с количеством кортежей в отношении Employee умноженное на количество кортежей в отношении Parking:

```
+-------------+---------------+------------+---------------+
| Employee.Id | Employee.Name | Parking.Id | Parking.Space |
+-------------+---------------+------------+---------------+
|        1001 | Bob           |       1001 |             6 |
|        1001 | Bob           |       1002 |             8 |
|        1001 | Bob           |       1004 |             1 |
|        1002 | Alice         |       1001 |             6 |
|        1002 | Alice         |       1002 |             8 |
|        1002 | Alice         |       1004 |             1 |
|        1003 | Rob           |       1001 |             6 |
|        1003 | Rob           |       1002 |             8 |
|        1003 | Rob           |       1004 |             1 |
+-------------+---------------+------------+---------------+
```

Декартово произведение в нашем случае является бинарным оператором, поэтому для соединения более двух отношении необходимо использовать скобки.

<p>$$Person \times (Employee \times Parking)$$</p>

Само по себе декартово произведение не так полезно, если его не использовать с другими операторами.

Например, мы хотим получить место парковки Боба. Для этого используя декартово произведение можно применить оператор выборки на сравнение Employee.Id и Parking.Id к результату полученного отношения:

<p>$$\pi_{Employee.Name, Parking.Space} (\sigma_{Employee.Id = Parking.Id \wedge Employee.Name = 'Bob'} (Employee \times Parking))$$</p>

В результате получим отношение

```
+---------------+---------------+
| Employee.Name | Parking.Space |
+---------------+---------------+
| Bob           |             6 |
+---------------+---------------+
```

# 1.8 Естественное соединение

Естественное соединение использует декартово произведение, но позволяет обеспечить сравнение значений всех атрибутов с одинаковым названием по умолчанию, а также устранить дубликаты атрибутов:

<p>$$Employee \bowtie Parking$$</p>
---
pub_date: 2018-12-13
---
toc: Содержание
