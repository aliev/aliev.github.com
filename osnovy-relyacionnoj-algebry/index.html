<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="stylesheet" href="../static/style.css">
    <link rel="stylesheet" href="../static/font-awesome.min.css">
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

    <title>Основы реляционной алгебры</title>
    <meta name="description" content="Основные понятия и операторы реляционной теории и реляционной алгебры." />
    <meta property="og:title" content="Основы реляционной алгебры" />
    <meta property="og:description" content="Основные понятия и операторы реляционной теории и реляционной алгебры." />
    <meta property="og:url" content="https://aliev.me/osnovy-relyacionnoj-algebry" />
    <meta property="og:type" content="website" />
    <meta property="og:site_name" content="Ali Aliev - blog" />
</head>
<body>
    <main>
        
  
  <div class="blog-post">
  
    <h1><a href="../"><-</a>&nbsp;Основы реляционной алгебры</h1>
  
  <p class="meta">
    Ali Aliyev
    [2019-01-06]
  </p>
  
    
      <h1>Содержание</h1>
    
  <ul class="toc">
      
      <li><a href="#1.0">1.0 Введение и основные понятия</a><ul>
      <li><a href="#1.1-?">1.1 Как устроена реляционная модель?</a>
      
      <li><a href="#1.2">1.2 Важная терминология</a>
      
      <li><a href="#1.3">1.3 Выполнение запросов в реляционных базах данных</a>
      
      <li><a href="#1.4">1.4 Дубликаты</a>
      </ul>
      
      <li><a href="#2.0">2.0 Операторы реляционной алгебры</a><ul>
      <li><a href="#2.1">2.1 Оператор выборки (ограничение)</a>
      
      <li><a href="#2.2">2.2 Оператор проекции</a>
      
      <li><a href="#2.3">2.3 Оператор переименования</a>
      </ul>
      
      <li><a href="#3.0">3.0 Объединение отношений</a><ul>
      <li><a href="#3.1">3.1 Декартово произведение</a>
      
      <li><a href="#3.2">3.2 Естественное соединение</a>
      
      <li><a href="#3.3">3.3 Тета соединение</a>
      </ul>
      
      <li><a href="#4.0">4.0 Множества</a><ul>
      <li><a href="#4.1">4.1 Оператор объединения</a>
      
      <li><a href="#4.2">4.2 Оператор разности</a>
      
      <li><a href="#4.3">4.3 Пересечение</a>
      </ul>
      
      <li><a href="#5.0">5.0 Дополнительные материалы</a>
      
  </ul>
  
  <h1 id="1.0">1.0 Введение и основные понятия</h1><h2 id="1.1-?">1.1 Как устроена реляционная модель?</h2><p>База данных это множество именованных отношений - таблиц. Отношение или "relatio" - фундаментальное понятие в реляционной модели именно поэтому модель называется реляционной.</p>
<p>Само по себе отношение является множеством, которое содержит список кортежей  представляющих строки таблицы. Например, если представить таблицу с тремя столбцами (Name, City, Job), то саму таблицу можно показать в виде множества кортежей:</p>
<div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="p">(</span><span class="n">Kris</span><span class="p">,</span> <span class="n">Berlin</span><span class="p">,</span> <span class="n">Database</span> <span class="n">Designer</span><span class="p">),</span>
    <span class="p">(</span><span class="n">Mike</span><span class="p">,</span> <span class="n">Zurich</span><span class="p">,</span> <span class="n">SRE</span><span class="p">),</span>
    <span class="p">(</span><span class="n">Harald</span><span class="p">,</span> <span class="n">Berlin</span><span class="p">,</span> <span class="n">Security</span> <span class="n">Engineer</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
<p>Кортежи отношения всегда не упорядочены, так как являются частью множества. Значения же кортежей всегда упорядочены, так как значения являются частью кортежей, а не множества. Тут важно заметить, что выражение ORDER BY в языке SQL не является частью его реляционной алгебры.</p>
<p>Каждый элемент кортежа представляет именованный атрибут или столбец. Обычно столбцы задаются во время создания таблицы и модифицируются редко (или даже никогда). Атрибуты имеют тип, который иногда называется доменом. Например Id может быть целым типом, имя может быть строкой, фото может быть файлом jpeg. Так же реляционные базы данных могут поддерживать концепцию перечисляемого домена. Например, штат может быть перечисляемым доменом из 50 сокращений.</p>
<p>Также есть специальное значение, которым может быть установлен столбец любого типа. Это специальное значение именуется NULL, оно играет очень важную роль в реляционных базах данных. NULL используются для обозначения того, что значение может быть неизвестным или неопределенным.</p>
<p>Еще одним важным атрибутом отношения является первичный ключ (primary key). Каждое значение такого атрибута должно быть уникальным. У подобных атрибутов есть несколько важных применений. Одно из них - извлечение определенных кортежей. Например, вы можете запросить кортеж по его уникальном ключу. В то же время система баз данных для эффективности строит специальную структуру индексов для более быстрого нахождения кортежей.</p>
<p>Более важное применение ключей это создание связей между кортежами отношений по их уникальному ключу, так как в реляционных базах данных нет концепции указателей. Такие ключи называются внешними ключами (foreign key).</p>
<h2 id="1.2">1.2 Важная терминология</h2><ul>
<li><p>Схема - структурированное описание отношения в базе данных. Схема содержит в себе название отношения, атрибуты этого отношения и типы этих атрибутов.</p>
</li>
<li><p>Экземпляр - фактическое содержание в данный момент времени. Схема устанавливается заранее, а затем экземпляры данных будут меняться со временем.</p>
</li>
</ul>
<h2 id="1.3">1.3 Выполнение запросов в реляционных базах данных</h2><p>Основные шаги в создании и использовании реляционных баз данных.</p>
<ul>
<li><p>Проектирования схемы; создание используя язык DDL (Data Definition Language). Схема содержит структуру отношений и атрибуты этих отношений.</p>
</li>
<li><p>Начальная загрузка исходных данных</p>
</li>
</ul>
<p>Реляционная алгебра это формальный язык, который формирует основы таких языков, как SQL.</p>
<p>Запросы в реляционных базах данных действуют на отношения, которые так же в свою очередь порождают новые отношения.</p>
<p>Самый простой запрос в реляционной алгебре это запрос самого отношения: $$Relation$$ который вернет его копию.</p>
<h2 id="1.4">1.4 Дубликаты</h2><p>Семантика реляционной алгебры устраняет дубликаты, так как она основана на множествах. Это немного отличает реляционную алгебру от языка SQL. Устранение дубликатов является ресурсоемкой задачей, поэтому нецелесообразно использовать обычные множества в языке SQL. Вместо этого используются мультимножества, где данные могут дублироваться, а устранение дубликатов можно добиться добавлением оператора DISTINCT.</p>
<h1 id="2.0">2.0 Операторы реляционной алгебры</h1><h2 id="2.1">2.1 Оператор выборки (ограничение)</h2><p>Оператор выборки служит для фильтрации определенных строк отношений. Оператор обозначается греческой буквой сигма <p>$$\sigma$$</p> с контекстом обозначающим условие, которое используется для фильтрации строк извлеченных из отношения:</p>
<p>
$$
\sigma_{condition}
Relation
$$
</p><p>Например, следующим запросом можно выбрать студентов университета "Stanford" с оценкой больше 3.7 учащихся на факультете "Computer Science":</p>
<p>
$$
\sigma_{
cName="Stanford" \wedge gpa > 3.7 \wedge major = "Computer Science"}
Student
$$
</p><h2 id="2.2">2.2 Оператор проекции</h2><p>Оператор проекции служит для выборки определенных столбцов отношения. Оператор обозначается греческой буквой пи <p>$$\pi$$</p> и в качестве контекста указывается список колонок:</p>
<p>
$$
\pi_{a_{1}...a_{n}}
Relation
$$
</p><p>Пример того, как можно комбинировать оператор выборки и проекции. Выберем id студентов с gpa &gt; 3.7:</p>
<p>
$$
\pi_{id}
(\sigma_{gpa>3.7}Student)
$$
</p><h2 id="2.3">2.3 Оператор переименования</h2><p>Как следует из названия оператор переименования позволяет переименовывать атрибуты отношений. Оператор переименования является унарным оператором и имеет следующую форму:</p>
<p>
$$
\rho_{new/original}
(Relation)
$$
</p><p>где <i>new</i> - новое название атрибута, <i>original</i> - старое название атрибута. Например для отношения:</p>
<pre><code>+------------------+
| Employee         |
+----------+-------+
| Id       | Name  |
+----------+-------+
| 1001     | Bob   |
| 1002     | Alice |
| 1003     | Rob   |
+----------+-------+
</code></pre>
<p>
$$
\rho_{EmployeeName/Name}
(\rho_{EmployeeId/Id}(Employee))
$$
</p><p>Получим новое отношение с переименованными атрибутами:</p>
<pre><code>+---------------------------+
|  Employee                 |
+------------+--------------+
| EmployeeId | EmployeeName |
+------------+--------------+
| 1001       | Bob          |
| 1002       | Alice        |
| 1003       | Rob          |
+------------+--------------+
</code></pre>
<p>Далее на примерах мы поймем почему данный оператор так важен.</p>
<h1 id="3.0">3.0 Объединение отношений</h1><h2 id="3.1">3.1 Декартово произведение</h2><p>Декартово произведение служит для комбинации двух отношений. Данный оператор берет два отношения создавая пары всех возможных комбинаций кортежей. Декартово произведение требует, чтобы у кортежей комбинируемых отношений было уникальное название атрибутов, в противном случае необходимо переименовывать атрибуты оператором переименования, который мы рассмотрели ранее. Например, два отношения:</p>
<pre><code>+----------+-------+
| Employee         |
+----------+-------+
| Id       | Name  |
+----------+-------+
| 1001     | Bob   |
| 1002     | Alice |
| 1003     | Rob   |
+----------+-------+
</code></pre>
<pre><code>+---------+-------+
| Parking         |
+---------+-------+
| Id      | Space |
+---------+-------+
| 1001    | 6     |
| 1002    | 8     |
| 1004    | 1     |
+---------+-------+
</code></pre>
<p>имеют общие атрибуты Id. Запрос можно выразить следующим образом, что бы избавиться от дубликатов атрибутов:</p>
<p>
$$
\rho_{EmployeeId/Id}
(Employee)
\times
\rho_{ParkingId/Id}
(Parking)
$$
</p><p>в результате получим отношение:</p>
<pre><code>+-------------+---------------+------------+---------------+
| EmployeeId  | Name          | ParkingId  | Space         |
+-------------+---------------+------------+---------------+
|        1001 | Bob           |       1001 |             6 |
|        1001 | Bob           |       1002 |             8 |
|        1001 | Bob           |       1004 |             1 |
|        1002 | Alice         |       1001 |             6 |
|        1002 | Alice         |       1002 |             8 |
|        1002 | Alice         |       1004 |             1 |
|        1003 | Rob           |       1001 |             6 |
|        1003 | Rob           |       1002 |             8 |
|        1003 | Rob           |       1004 |             1 |
+-------------+---------------+------------+---------------+
</code></pre>
<p>Декартово произведение в нашем случае является бинарным оператором, поэтому для соединения более двух отношении необходимо использовать скобки.</p>
<p>
$$
Person
\times
(Employee \times Parking)
$$
</p><p>Само по себе декартово произведение не так полезно, если его не использовать с другими операторами.</p>
<p>Например, мы хотим получить место парковки Боба. Для этого используя декартово произведение можно применить оператор выборки на сравнение EmployeeId и ParkingId к результату полученного отношения:</p>
<p>
$$
\pi_{Name, Space}
(\sigma_{EmployeeId = ParkingId \wedge Name = 'Bob'} (\rho_{EmployeeId/Id}(Employee) \times \rho_{ParkingId/Id}(Parking)))
$$
</p><p>В результате получим отношение</p>
<pre><code>+------+-------+
| Name | Space |
+------+-------+
| Bob  |     6 |
+------+-------+
</code></pre>
<h2 id="3.2">3.2 Естественное соединение</h2><p>Естественное соединение использует декартово произведение, но позволяет обеспечить сравнение значений всех атрибутов с одинаковым названием по умолчанию, а также устранить дубликаты атрибутов:</p>
<p>
$$
Employee
\bowtie
Parking
$$
</p><pre><code>+------+-------+-------+
|  Id  | Name  | Space |
+------+-------+-------+
| 1001 | Bob   |     6 |
| 1002 | Alice |     8 |
+------+-------+-------+
</code></pre>
<p>Пример решения задачи отображения места парковки Боба используя оператор естественного соединения:</p>
<p>$$\pi_{Name, Space}(\sigma_{Name = 'Bob'}(Employee \bowtie Parking))$$</p><pre><code>
+------+-------+
| Name | Space |
+------+-------+
| Bob  |     6 |
+------+-------+
</code></pre>
<h2 id="3.3">3.3 Тета соединение</h2><p>Тета соединение, так же как и естественное соединение является всего лишь сокращенной записью оператора выборки и декартова произведения. Тета - это контекст, в который передается условное выражения вместо оператора выборки:</p>
<p>$$Exp_{1} \bowtie_{\theta}(Exp_{1} \times Exp_{2})$$</p><p>В большинстве реляционных базах данных в качестве оператора JOIN используется именно тета соединение.</p>
<p>Для наглядности мы можем переписать наш предыдущий запрос получения места парковки Боба используя тета соединение:</p>
<p>$$\pi_{Name, Space}(Employee \bowtie_{Name='Bob'} Parking)$$</p><h1 id="4.0">4.0 Множества</h1><h2 id="4.1">4.1 Оператор объединения</h2><p>Все операторы, которые были описаны выше используются для объединения кортежей таблиц по горизонтали. А что если необходимо объединить в один список значения из разных таблиц? Для этого удобнее всего будет воспользоваться оператором объединения. Например, можно объединить столбцы Id отношений Parking и Employee:</p>
<p>$$\pi_{Id}Employee \cup \pi_{Id}Parking$$</p><pre><code>+------+
|  Id  |
+------+
| 1001 |
| 1002 |
| 1003 |
| 1004 |
+------+
</code></pre>
<p>Оператор объединения ожидает, что типы объединяемых столбцов, их название и их количество должно быть одинаковым. Для объединения столбцов с разными названиями можно воспользоваться оператором переименования:</p>
<p>
$$
\rho_{name/cName}
(\pi_{cName} College)
\cup
\rho_{name/sName}
(\pi_{sName} Student)
$$
</p><h2 id="4.2">4.2 Оператор разности</h2><p>Оператор разности для отношений работает так же как и для множеств, так как отношения являются сами по себе множествами, как мы рассмотрели ранее.</p>
<p>Например, нам нужно получить список свободных парковочных мест. Для этого мы можем применить оператор разности между отношениями Employee и Parking:</p>
<p>$$\pi_{Id} Parking - \pi_{Id} Employee$$</p><pre><code>+------+
|  Id  |
+------+
| 1004 |
+------+
</code></pre>
<p>Но данный запрос в качестве результата покажет только Id парковочных мест. Что если мы хотели бы показать еще и номера свободных парковочных мест? Мы не можем добавить в контекст проекции атрибут Space, так как это исказит наше множество. Для этого мы можем применить естественное соединение к полученному результату из множества Id свободных парковочных мест:</p>
<p>
$$
\pi_{Id, Space}
((\pi_{Id}Parking - \pi_{Id}Employee) \bowtie Parking)
$$
</p><pre><code>+------+-------+
|  Id  | Space |
+------+-------+
| 1004 |     1 |
+------+-------+
</code></pre>
<h2 id="4.3">4.3 Пересечение</h2><p>Оператор пересечения возвращает общие элементы двух множеств. Пересечение множеств можно представить в виде равенства:</p>
<p>$$E_{1} \cap E_{2} \equiv E_{1} - (E_{1} - E_{2})$$</p><p>Пересечение множеств можно заменить естественным соединением:</p>
<p>$$E_{1} \cap E_{2} \equiv E_{1} \bowtie E_{2}$$</p><h1 id="5.0">5.0 Дополнительные материалы</h1><p><a href="https://lagunita.stanford.edu/courses/Home/Databases/Engineering/about">Introduction to Databases</a></p>
<p><a href="https://dbis-uibk.github.io/relax/calc.htm">RelaX - relational algebra calculator</a></p>
<p><a href="https://blog.jooq.org/2016/07/05/say-no-to-venn-diagrams-when-explaining-joins/">Say NO to Venn Diagrams When Explaining JOINs</a></p>

  </div>

  <a href="https://twitter.com/intent/tweet?screen_name=ali_aliev&ref_src=twsrc%5Etfw" class="twitter-mention-button"
    data-show-count="false">Tweet to @ali_aliev</a>
  <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

    </main>
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-42591955-1', 'auto');
        ga('send', 'pageview');

    </script>
</body>
</html>
